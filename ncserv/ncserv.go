package main

/*
 * ncserv.go
 * Server side for a netcat connection
 * By J. Stuart McMurray
 * Created 20160223
 * Last Modified 20160223
 */

import (
	"flag"
	"fmt"
	"log"
	"net"
	"os"
	"os/exec"
	"runtime"
)

func main() {
	/* No windows support, yet */
	if "windows" == runtime.GOOS {
		log.Fatalf("No Windows support yet.  Please submit a patch.")
	}

	var (
		addr = flag.String(
			"a",
			"0.0.0.0:0",
			"Listen `address`",
		)
		name = flag.String(
			"n",
			"cron",
			"Process `name`",
		)
	)
	flag.Usage = func() {
		fmt.Fprintf(
			os.Stderr,
			`Usage: %v [options]

Listens, passes connections to a shell.  Meant to be used when ncat, socat, and
so on are unavailable or undesirable.

Options:
`,
			os.Args[0],
		)
		flag.PrintDefaults()
	}
	flag.Parse()

	/* Listen */
	l, err := net.Listen("tcp", *addr)
	if nil != err {
		log.Fatalf("Listen: %v", err)
	}
	log.Printf("Listening on %v", l.Addr())
	/* Accept and handle */
	for {
		c, err := l.Accept()
		if nil != err {
			log.Fatalf("Accept: %v", err)
		}
		log.Printf("%v - Start", c.RemoteAddr())
		go handle(c, *name)
	}
}

/* handle handles a connection */
func handle(c net.Conn, n string) {
	defer c.Close()
	/* Say hello. */
	if _, err := c.Write([]byte("Connected.\n")); nil != err {
		log.Printf("%v - Hello: %v", c.RemoteAddr(), err)
	}

	/* Spawn sh */
	cmd := exec.Command("/bin/sh")
	cmd.Path = "/bin/sh"
	cmd.Args = []string{n}
	cmd.Stdin = c
	cmd.Stdout = c
	cmd.Stderr = c
	if err := cmd.Start(); nil != err {
		log.Printf("%v - /bin/sh: %v", c.RemoteAddr(), err)
		return
	}

	/* Wait for it to end */
	if err := cmd.Wait(); nil != err {
		log.Printf("%v - Done: %v", c.RemoteAddr(), err)
		return
	}
	log.Printf("%v - Done.", c.RemoteAddr())
}
