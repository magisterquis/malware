package main

/*
 * server.go
 * Struct representing a server
 * By J. Stuart McMurray
 * Created 20160723
 * Last Modified 20160728
 */

import (
	"bytes"
	"crypto/rand"
	"crypto/tls"
	"fmt"
	"io"
	"net"
	"regexp"
	"runtime"
	"sync"
	"time"
)

/* Server-related Errors */
var (
	ErrMsgTooLong = fmt.Errorf(message_too_long_rs)
)

/* Maximum size of a command, less \r\n */
const MAXCMDLEN = 510

/* Channel represents a channel/key pair */
type Channel struct {
	Name string /* Channel name */
	Key  string /* Channel key (password) */
}

/* Server defines a server connection */
type Server struct {
	/* Configurable settings */
	Host     string    /* host:port pair */
	TLS      bool      /* Connect via TLS or no */
	Channels []Channel /* Channels to which to connect */
	Admins   []string  /* Nicks which can talk to the bot */
	Password string    /* Server password */
	Username string    /* Username */
	Realname string    /* Real name */

	/* Users shouldn't touch these */
	stop     bool             /* True when we should stop reconnecting */
	c        net.Conn         /* Connection to server */
	wlock    *sync.Mutex      /* Prevent interleaved writes */
	nick     string           /* IRC Nickname */
	clock    *sync.Mutex      /* Channel slice lock */
	adminREs []*regexp.Regexp /* Admin regular expressions */

	/* Protocol message buffer */
	plock *sync.Mutex /* Lock for the PM buffer */
	pmbuf []string    /* PM buffer itself */
	pmnxt int         /* Current element of the pm buffer */
}

/* Do connects to the server, and reconnects upon disconnect */
func (s *Server) Do(wg *sync.WaitGroup) {
	defer wg.Done()
	var (
		err error
	)
	/* Make sure the locks are locks */
	s.wlock = &sync.Mutex{}
	s.clock = &sync.Mutex{}
	s.plock = &sync.Mutex{}

	/* Initialize protocol message buffer */
	s.pmbuf = make([]string, 0, PROTOMSGS)

	/* Make admin regular expressions */
	s.adminREs = make([]*regexp.Regexp, len(s.Admins))
	for i, v := range s.Admins {
		s.adminREs[i] = regexp.MustCompile(v)
	}
	/* Connect to the server every so often */
	for !s.stop {
		/* Connect with TLS or plaintext, as appropriate */
		if s.TLS {
			//s.c, err = tls.Dial(tcp_rs, s.Host, nil)
			s.c, err = tls.Dial(tcp_rs, s.Host, &tls.Config{
				InsecureSkipVerify: true,
			})
		} else {
			s.c, err = net.Dial(tcp_rs, s.Host)
		}
		/* Reconnect on error */
		if nil != err {
			debug(
				Unable_to_connect_to__v__TLS___v____v_rs,
				s.Host,
				s.TLS,
				err,
			)
			/* Wait before reconnecting */
			time.Sleep(RCDELAY)
			continue
		}
		debug(Connected_to__v___v_TLS___v__rs,
			s.Host,
			s.c.RemoteAddr(),
			s.TLS,
		)

		/* Register */
		go func() {
			if err := s.Register(); nil != err {
				debug(
					Unable_to_register_to__v___v____v_rs,
					s.Host,
					s.c.RemoteAddr(),
					err,
				)
				return
			}
		}()

		/* Handle inbound messages */
		if err := s.HandleRXMessages(); nil != err {
			debug(
				"Receive error from %v (%v): %v",
				s.Host,
				s.c.RemoteAddr(),
				err,
			)
		}
	}
}

/* Send safely sends the message to the target.  It is safe to be called from
multiple goroutines simultaneously.  The number of bytes sent (not including
the required \r\n) as well as any errors are returned. */
func (s *Server) Send(msg []byte) (int, error) {
	s.wlock.Lock()
	defer s.wlock.Unlock()
	/* Don't send too much */
	if MAXCMDLEN < len(msg) {
		/* TODO: Randomify */
		debug("Message too long: %q", msg)
		return 0, ErrMsgTooLong
	}
	/* Send the message */
	n, err := s.c.Write(msg)
	if nil != err {
		return n, err
	}
	/* Append a \r\n */
	_, err = s.c.Write([]byte{0x0D, 0x0A})
	return n, err
}

/* SendMsg sends a privmsg to the target.  The message will be split on lines
and chunked so as to not overflow the maximum message length. */
func (s *Server) SendMsg(target string, message []byte) error {
	return s.SendStream(target, bytes.NewBuffer(message), nil)
}

/* SendStream reads from stream and sends to target.  The stream will be split
as for SendMsg. */
func (s *Server) SendStream(
	target string,
	stream io.Reader,
	wg *sync.WaitGroup,
) error {
	if nil != wg {
		defer wg.Done()
	}
	if "" == target {
		return fmt.Errorf(no_target_specified_rs)
	}

	ibuf := make([]byte, 1)                      /* Input buffer */
	buf := make([]byte, 0, MAXCMDLEN)            /* Message buffer */
	scmd := fmt.Sprintf(PRIVMSG__v___rs, target) /* Send command */
	var (
		n    int
		err  error
		ierr error
	)

	/* Put the command in the buffer */
	buf = append(buf, scmd...)

	/* Put message bytes into the buffer */
	for {
		n, ierr = stream.Read(ibuf)
		/* Add the byte to the buffer if we got one */
		if 1 == n {
			/* Skip linefeeds */
			if '\r' == ibuf[0] {
				continue
			}
			/* Put the byte in the send buffer if it's not a
			newline */
			if ibuf[0] != '\n' {
				buf = append(buf, ibuf[0])
			}
		}
		/* If the current byte's a newline, or the buffer is big
		enough, send it */
		if (1 == n && ibuf[0] == '\n') ||
			len(buf) == cap(buf) ||
			(nil != ierr && (1 == n || len(buf) != len(scmd))) {
			/* Make sure the buffer at least has a space */
			if nil == ierr && (len(buf) == len(scmd)) {
				buf = append(buf, ' ')
			}

			/* Send it off */
			if _, err = s.Send(buf); nil != err {
				return err
			}
			/* Sleep (to prevent flooding) and reset the buffer */
			time.Sleep(MSGDELAY)
			buf = buf[:len(scmd)]
		}
		if nil != ierr {
			break
		}
	}
	return nil
}

/* Register sends the realname and username and sets the nick */
func (s *Server) Register() error {
	/* Send the password if there is one */
	if "" != s.Password {
		if _, err := s.Send([]byte(fmt.Sprintf(
			PASS__v_rs,
			s.Password,
		))); nil != err {
			return err
		}
	}

	/* Send the nick */
	if err := s.SetNick(); nil != err {
		return err
	}

	/* Send the user/real names */
	if "" == s.Username {
		s.Username = USERNAME
	}
	if "" == s.Realname {
		s.Realname = REALNAME
	}
	if _, err := s.Send([]byte(fmt.Sprintf(
		USER__v_0_____v_rs,
		s.Username,
		s.Realname,
	))); nil != err {
		return err
	}

	/* Join the channels */
	return s.JoinAll()
}

/* SetNick makes a nick if we don't have one and sends it */
func (s *Server) SetNick() error {
	/* Make a new nick if we don't have one */
	if "" == s.nick {
		/* Get numbers for after our nick */
		b := make([]byte, NICKLEN-len(runtime.GOOS))
		if _, err := rand.Read(b); nil != err {
			return err
		}
		/* Put together our nick */
		s.nick = runtime.GOOS + string('|') + fmt.Sprintf(_02X_rs, b)
	}
	/* Send the nick */
	_, err := s.Send([]byte(fmt.Sprintf(NICK__v_rs, s.nick)))
	return err
}

/* JoinOne joins a single channel, and saves the channel for rejoining
in case of disconnection. */
func (s *Server) JoinOne(name, key string) error {
	s.clock.Lock()
	defer s.clock.Unlock()
	c := Channel{Name: name, Key: key}
	/* Make sure channel is in the list */
	found := false
	for _, sc := range s.Channels {
		if sc.Name == c.Name {
			found = true
			break
		}
	}
	if !found {
		s.Channels = append(s.Channels, c)
	}

	/* Join channel */
	return s.join(c)
}

/* join joins a channel */
func (s *Server) join(c Channel) error {
	/* Command to join the channel */
	cmd := fmt.Sprintf(JOIN__v_rs, c.Name)
	/* Add in the key if we have one */
	if "" != c.Key {
		cmd += string(' ') + c.Key
	}
	/* Send it */
	_, err := s.Send([]byte(cmd))
	return err
}

/* JoinAll joins all the saved channels */
func (s *Server) JoinAll() error {
	for _, c := range s.Channels {
		if err := s.join(c); nil != err {
			return err
		}
	}
	return nil
}

/* Part leaves a channel */
func (s *Server) Part(channel, message string) error {
	s.clock.Lock()
	defer s.clock.Unlock()
	/* Remove channel from list of channels to join */
	nc := make([]Channel, 0, len(s.Channels)-1)
	for _, c := range s.Channels {
		if channel != c.Name {
			nc = append(nc, c)
		}
	}
	s.Channels = nc

	/* TODO: Randomify */
	cmd := []byte(fmt.Sprintf("PART %v :%v", channel, message))
	if MAXCMDLEN < len(cmd) {
		cmd = cmd[:MAXCMDLEN]
	}
	_, err := s.Send(cmd)
	return err
}

/* TODO: Function */
