package main

/*
 * commands.go
 * Framework for commands
 * By J. Stuart McMurray
 * Created 201600725
 * Last Modified 201600725
 */

import (
	"fmt"
	"strings"
	"sync"
)

/* Command represents a _ command */
type Command struct {
	Do   func(s *Server, replyto, args string) error /* Run the command */
	Help string                                      /* Help text */
}

var (
	commands    map[string]*Command = map[string]*Command{}
	commandLock *sync.Mutex         = &sync.Mutex{}
)

/* GetCommend returns the command named name. */
func GetCommand(name string) *Command {
	/* Well, this is silly */
	return commands[name]
}

/* RegisterCommand should be called in the command's init().  It will panic if
called twice for commands with the same name */
func RegisterCommand(name string, c *Command) {
	commandLock.Lock()
	defer commandLock.Unlock()
	/* Don't duplicate */
	if _, ok := commands[name]; ok {
		panic(Duplicate_command__rs + name)
	}
	commands[name] = c
}

/* RunCommand runs the command contained in c, as sent by the sender (less the
leading _). */
func (s *Server) RunCommand(c, replyto string) {
	/* Pull apart the command and arguments */
	parts := strings.SplitN(c, string(' '), 2)
	if 1 > len(parts) {
		panic(Unpossible_command__rs + c)
	}
	/* Find the command */
	cmd := GetCommand(parts[0])
	if nil == cmd {
		s.SendMsg(replyto, []byte(fmt.Sprintf(
			Command__v_not_implemented_rs,
			parts[0],
		)))
		return
	}

	/* Command arguments */
	args := ""
	if 2 == len(parts) {
		args = parts[1]
	}

	/* Run the command */
	if err := cmd.Do(s, replyto, args); nil != err {
		s.SendMsg(replyto, []byte(fmt.Sprintf(
			Command__v_error___v_rs,
			parts[0],
			err,
		)))
	}

}
