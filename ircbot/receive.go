package main

/*
 * receive.go
 * Handle messages received from the Server
 * By J. Stuart McMurray
 * Created 20160723
 * Last Modified 20160728
 */

import (
	"bufio"
	"fmt"
	"os/exec"
	"strings"
	"sync"
)

/* HandleRXMessages handles messages received from the server. */
func (s *Server) HandleRXMessages() error {
	/* Fancypants reader for the connection */
	scanner := bufio.NewScanner(s.c)
	/* Handle each line of input */
	var (
		line   string /* Received line */
		source string /* Message source */
		mtype  string /* Message type */
		args   string /* Message arguments */
		err    error
	)

	for scanner.Scan() {
		/* Received line */
		line = scanner.Text()
		/* Ignore blank lines */
		if "" == line {
			continue
		}
		/* Short-circuit pings */
		if strings.HasPrefix(strings.ToUpper(line), PING_rs) {
			/* Pings */
			if PRINTPING {
				debug(_v_rs, line)
			}
			if err := s.Pong(line); nil != err {
				return err
			}
			continue
		}
		/* Extract parts of the message */
		source, mtype, args = splitMessage(line)
		switch mtype {
		case _001_rs: /* Registration successful */
			s.HandleRegistrationSuccess(args)
		case PRIVMSG_rs: /* Privmsg */
			err = s.HandlePrivmsg(source, args)
		default:
			/* Add to the protocol message buffer */
			s.PMBufAdd(line)
			debug(
				_Source___q___Mtype___q___Args___q__rs,
				source,
				mtype,
				args,
			)
		}
		if nil != err {
			return err
		}
	}
	if err := scanner.Err(); err != nil {
		return err
	}
	return nil
}

/* Pong replies to a ping */
func (s *Server) Pong(l string) error {
	l = PONG_rs + l[4:]
	_, err := s.Send([]byte(l))
	if PRINTPING {
		debug(_v_rs, l)
	}
	return err
}

/* Privmsg handles a private message */
func (s *Server) HandlePrivmsg(source, args string) error {
	var (
		target  string /* Where the message was sent (nick/channel) */
		message string /* Message itself */
		replyto string /* Where to send the reply */
	)
	/* Split off target and message */
	parts := strings.SplitN(args, string(' '), 2)
	if 2 != len(parts) {
		debug(Short_message_from__v___q_rs, source, args)
		return nil
	}
	target = parts[0]
	message = parts[1]
	/* Remove leading : from message, if there is one */
	if ':' == message[0] {
		message = message[1:]
	}
	/* Work out reply-to address */
	if target == s.nick {
		replyto = source
	} else {
		replyto = target
	}
	/* Make sure the replyto is only a nick */
	if strings.Contains(replyto, string('!')) {
		parts := strings.SplitN(replyto, string('!'), 2)
		replyto = parts[0]
	}
	debug(
		Privmsg_from__v_to__q__reply_to__v____q_rs,
		source,
		target,
		replyto,
		message,
	)

	/* Ignore one-character messages */
	if 1 >= len(message) {
		return nil
	}

	/* Only bother with messages from authorized senders */
	auth := false
	for _, re := range s.adminREs {
		if re.Match([]byte(source)) {
			auth = true
			break
		}
	}
	if !auth {
		return nil
	}

	/* Handle various types of messages */
	switch message[0] {
	case '*': /* Shell commands start with a ` */
		go s.ShellCommand(message[1:], replyto) /* DEBUG */
	case '_': /* Bot commands start with a _ */
		go s.RunCommand(message[1:], replyto)
	}

	/* TODO: Make help */

	/* Everything else is chatter */
	return nil
}

/* splitMessage splits the important bits out of a message */
func splitMessage(m string) (sender, mtype, arguments string) {
	/* Split off the first bit */
	parts := strings.SplitN(m, string(' '), 2)
	if 2 != len(parts) {
		mtype = parts[0]
		return
	}
	/* If there's no sender, return what we have */
	if ':' != parts[0][0] {
		mtype = parts[0]
		arguments = parts[1]
		return
	}
	/* Extract the message type and arguments */
	sender = parts[0][1:]
	parts = strings.SplitN(parts[1], string(' '), 2)
	if 0 == len(parts) { /* wtf? */
		return
	}
	mtype = parts[0]
	if 2 == len(parts) {
		arguments = parts[1]
	}
	return
}

/* HandleRegistrationSuccess works out our own nick from the post-registration
messages */
func (s *Server) HandleRegistrationSuccess(m string) {
	/* Chop off the first bit */
	parts := strings.SplitN(m, string(' '), 2)
	if 2 != len(parts) {
		debug(Odd_registration_message___q_rs, m)
		return
	}
	s.nick = parts[0]
	debug(Server_returned_nick___v_rs, s.nick)
}

/* ShellCommand runs c as a shell command, and sends the output to r */
func (s *Server) ShellCommand(c, r string) {
	/* TODO: Timeout */
	if strings.Contains(c, "kill") {
		s.SendMsg(r, []byte("Thou shalt not kill")) /* DEBUG */
		return
	}
	/* Echo command to be run */
	if err := s.SendMsg(
		r,
		[]byte(fmt.Sprintf(Running__q_rs, c)),
	); nil != err {
		return
	}
	/* Command to be run */
	cmd := exec.Command(_bin_sh_rs, _c_rs, c)
	/* Output pipes */
	os, oerr := cmd.StdoutPipe()
	es, eerr := cmd.StderrPipe()
	err := oerr
	if nil == oerr && nil != eerr {
		err = eerr
	}
	if nil != err {
		s.SendMsg(r, []byte(Pipe___rs+err.Error()))
		return
	}
	/* Run the command, get its output */
	if err := cmd.Start(); nil != err {
		s.SendMsg(r, []byte(Start___rs+err.Error()))
		return
	}
	wg := &sync.WaitGroup{}
	wg.Add(2)
	go s.SendStream(r, os, wg)
	go s.SendStream(r, es, wg)
	wg.Wait()
	if err := cmd.Wait(); nil != err {
		s.SendMsg(r, []byte(Error___rs+err.Error()))
	}
}
