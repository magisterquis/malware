package main

/*
 * tcp.go
 * Send commands via tcp
 * By J. Stuart McMurray
 * Created 20160227
 * Last Modified 20160227
 */

import (
	"log"
	"net"
)

/* tcp reads lines from stdin and sends them to raddr.  If ka is true, only
one connection will be made, and it won't be closed.  Otherwise, a new
connection will be made for every command sent. */
func tcp(laddr string, raddr string, stdin <-chan string, ka bool) {
	/* Resolve the addresses */
	la := resolveTCP(laddr)
	ra := resolveTCP(raddr)
	/* Connection, initally unconnected */
	var c *net.TCPConn
	defer c.Close()

	/* Read lines from stdin */
	var n int
	var err error
	for l := range stdin {
		/* If we're not connected, connect */
		if nil == c {
			c = dialTCP(la, ra)
			log.Printf("Connected %v -> %v", la, ra)
		}
		/* Send the data */
		n, err = c.Write([]byte(l))
		if nil != err {
			log.Fatalf("Send error: %v", err)
		}
		log.Printf("Sent %v bytes", n)
		/* Disconnect if we're not to keep the line open */
		if !ka {
			c.Close()
			log.Printf("Closed connection.")
			c = nil
		}
	}
}

/* resolveTCP resolves a TCP address, or kills the program */
func resolveTCP(addr string) *net.TCPAddr {
	a, err := net.ResolveTCPAddr("tcp", addr)
	if nil != err {
		log.Fatalf("Unable to resolve TCP address %q: %v", addr, err)
	}
	return a
}

/* dialTCP makes a TCP connection from l to r and dies if it fails. */
func dialTCP(l, r *net.TCPAddr) *net.TCPConn {
	c, err := net.DialTCP("tcp", l, r)
	if nil != err {
		log.Fatalf(
			"Unable to make TCP connection from %v to %v: %v",
			l,
			r,
			err,
		)
	}
	return c
}
